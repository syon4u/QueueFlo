import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { z } from "https://deno.land/x/zod@v3.22.4/mod.ts";
import { withAuth, corsHeaders, AuthContext } from "../_shared/auth.ts";
// Assuming Database types are generated by Supabase and available
// import { Database } from "../_shared/types.ts"; 

// Schemas based on the new database structure from solution_architecture.md

const AppointmentStatusEnum = z.enum([
    'scheduled',
    'checked_in',
    'servicing', // replacing 'in_progress'
    'completed',
    'cancelled',
    'no_show'
]);

const CreateAppointmentBaseSchema = z.object({
  service_id: z.string().uuid("Invalid service ID format"),
  location_id: z.string().uuid("Invalid location ID format"),
  scheduled_time: z.string().datetime("Invalid scheduled time format"),
  customer_notes: z.string().optional(), // Renamed from reason_for_visit and notes
  staff_id_assigned: z.string().uuid("Invalid staff ID format").optional(),
});

const CreateNewCustomerAppointmentSchema = CreateAppointmentBaseSchema.extend({
  customer_name: z.string().min(1, "Customer name is required"),
  phone_number: z.string().min(1, "Phone number is required"), // Assuming phone is primary for new customer creation
  email: z.string().email("Invalid email format").optional(), // Added email for new customer
});

const CreateExistingCustomerAppointmentSchema = CreateAppointmentBaseSchema.extend({
  customer_id: z.string().uuid("Invalid customer ID format"),
});

const UpdateAppointmentSchema = z.object({
  status_new: AppointmentStatusEnum.optional(), // Using status_new as per migration
  customer_notes: z.string().optional(),
  service_start_time: z.string().datetime().optional(),
  service_end_time: z.string().datetime().optional(),
  check_in_time: z.string().datetime().optional(),
  staff_id_assigned: z.string().uuid().optional(),
  cancellation_reason: z.string().optional(),
  service_id: z.string().uuid().optional(),
  location_id: z.string().uuid().optional(),
  scheduled_time: z.string().datetime().optional(),
});

// Schema for initiating a reminder (actual sending logic will be separate)
const ScheduleReminderSchema = z.object({
  appointment_id: z.string().uuid("Invalid appointment ID format"),
  message_template_id: z.string().uuid("Invalid message template ID format"),
  reminder_type: z.enum(["email", "sms"]), // Align with new table
  send_at: z.string().datetime("Invalid send_at time format"),
});

// Type for appointment responses (adjust based on actual select queries)
// This is a simplified example, actual response might join more data
type AppointmentResponse = {
  id: string;
  customer_id: string | null; // customer_id can be null if not linked to a profile
  service_id: string;
  location_id: string;
  staff_id_assigned: string | null;
  status_new: string; // Using status_new
  scheduled_time: string;
  check_in_time: string | null;
  service_start_time: string | null;
  service_end_time: string | null;
  customer_notes: string | null;
  cancellation_reason: string | null;
  reschedule_original_appointment_id: string | null;
  created_at: string;
  updated_at: string;
};

const appointmentHandler = withAuth(async (req: Request, ctx: AuthContext) => {
  const url = new URL(req.url);
  const method = req.method;
  const { user, supabase } = ctx; // user from withAuth is the authenticated Supabase user

  try {
    // --- Schedule a Reminder (POST /appointments/:id/schedule-reminder) ---
    if (method === "POST" && url.pathname.match(/\/appointments\/[^\/]+\/schedule-reminder$/)) {
      const appointmentId = url.pathname.split("/")[2];
      const body = await req.json();
      const validation = ScheduleReminderSchema.safeParse(body);

      if (!validation.success) {
        return new Response(JSON.stringify({ error: "Invalid request data for scheduling reminder", details: validation.error.format() }), {
          status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      const reminderData = validation.data;

      // Authorization: Check if user can schedule reminder (e.g., staff/admin)
      // This part needs robust role checking based on your 'user_roles' or 'profiles' table
      const { data: userProfile, error: profileError } = await supabase
        .from('profiles') // Assuming role is in profiles table or a user_roles table
        .select('role')
        .eq('id', user.id)
        .single();

      if (profileError || !userProfile || !['staff', 'admin'].includes(userProfile.role)) {
        return new Response(JSON.stringify({ error: "Unauthorized to schedule reminders" }), {
            status: 403, headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }

      const { data: reminder, error: insertError } = await supabase
        .from('reminders') 
        .insert({
          appointment_id: appointmentId, // Use appointmentId from path
          message_template_id: reminderData.message_template_id,
          reminder_type: reminderData.reminder_type,
          send_at: reminderData.send_at,
          status: 'pending', // Default status
        })
        .select()
        .single();

      if (insertError) {
        console.error("Error inserting reminder:", insertError);
        return new Response(JSON.stringify({ error: "Failed to schedule reminder", details: insertError.message }), {
          status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      return new Response(JSON.stringify(reminder), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
    }

    // --- Create New Appointment (POST /appointments) ---
    if (method === "POST" && url.pathname.endsWith("/appointments")) {
      const body = await req.json();
      let validatedData;
      let customerIdToUse: string | null = null;

      if ('customer_id' in body) {
        const validation = CreateExistingCustomerAppointmentSchema.safeParse(body);
        if (!validation.success) {
          return new Response(JSON.stringify({ error: "Invalid request data for existing customer appointment", details: validation.error.format() }), {
            status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }
        validatedData = validation.data;
        customerIdToUse = validatedData.customer_id;
      } else {
        const validation = CreateNewCustomerAppointmentSchema.safeParse(body);
        if (!validation.success) {
          return new Response(JSON.stringify({ error: "Invalid request data for new customer appointment", details: validation.error.format() }), {
            status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" }
          });
        }
        validatedData = validation.data;
        // For new customer, create a profile first (or handle anonymous if your schema allows)
        // This assumes 'profiles' table stores customer details and links to auth.users
        // A more robust solution might involve checking if a user with that email/phone already exists.
        const { data: newProfile, error: profileInsertError } = await supabase
            .from('profiles') // Or your 'customers' table if separate
            .insert({
                // id: user.id, // If creating an authenticated user profile
                full_name: validatedData.customer_name, // Adjust fields as per your 'profiles' table
                phone: validatedData.phone_number,
                email: validatedData.email,
                role: 'customer' // Default role
            })
            .select('id')
            .single();
        
        if (profileInsertError) {
            console.error("Error creating customer profile:", profileInsertError);
            return new Response(JSON.stringify({ error: "Failed to create customer profile", details: profileInsertError.message }), {
                status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" }
            });
        }
        customerIdToUse = newProfile.id;
      }

      const { data: appointment, error: appointmentError } = await supabase
        .from('appointments')
        .insert({
          customer_id: customerIdToUse,
          service_id: validatedData.service_id,
          location_id: validatedData.location_id,
          scheduled_time: validatedData.scheduled_time,
          customer_notes: validatedData.customer_notes,
          staff_id_assigned: validatedData.staff_id_assigned,
          status_new: 'scheduled', // Default status
        })
        .select("*, service:services(name), location:locations(name), customer:profiles(full_name, email, phone)") // Example of joining related data
        .single();

      if (appointmentError) {
        console.error("Error creating appointment:", appointmentError);
        return new Response(JSON.stringify({ error: "Failed to create appointment", details: appointmentError.message }), {
          status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      return new Response(JSON.stringify(appointment as AppointmentResponse), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
    }

    // --- List Appointments (GET /appointments) ---
    if (method === "GET" && url.pathname.endsWith("/appointments")) {
      // Add query parameter parsing for filtering (e.g., by location, date, status)
      const { data: userProfile } = await supabase.from('profiles').select('role, location_id').eq('id', user.id).single();
      const userRole = userProfile?.role || 'customer';

      let query = supabase
        .from('appointments')
        .select(`
            id, customer_id, service_id, location_id, staff_id_assigned, status_new, 
            scheduled_time, check_in_time, service_start_time, service_end_time, 
            customer_notes, cancellation_reason, reschedule_original_appointment_id, 
            created_at, updated_at,
            service:services(name, description),
            location:locations(name),
            staff:profiles!appointments_staff_id_assigned_fkey(full_name),
            customer:profiles!appointments_customer_id_fkey(full_name, email, phone)
        `);

      if (userRole === 'customer') {
        query = query.eq('customer_id', user.id);
      } else if (userRole === 'staff' && userProfile?.location_id) {
        // Staff see appointments for their location or assigned to them
        query = query.or(`location_id.eq.${userProfile.location_id},staff_id_assigned.eq.${user.id}`);
      }
      // Admins see all (no additional filter)

      // Add filters from query params e.g. date_from, date_to, location_id, service_id, status_new
      const dateFrom = url.searchParams.get('date_from');
      const dateTo = url.searchParams.get('date_to');
      const filterLocationId = url.searchParams.get('location_id');
      const filterServiceId = url.searchParams.get('service_id');
      const filterStatus = url.searchParams.get('status_new');

      if (dateFrom) query = query.gte('scheduled_time', dateFrom);
      if (dateTo) query = query.lte('scheduled_time', dateTo);
      if (filterLocationId) query = query.eq('location_id', filterLocationId);
      if (filterServiceId) query = query.eq('service_id', filterServiceId);
      if (filterStatus) query = query.eq('status_new', filterStatus);
      
      query = query.order('scheduled_time', { ascending: true });

      const { data: appointments, error } = await query;

      if (error) {
        console.error("Error fetching appointments:", error);
        return new Response(JSON.stringify({ error: "Failed to fetch appointments", details: error.message }), {
          status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      return new Response(JSON.stringify(appointments as AppointmentResponse[]), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
    }

    // --- Get Single Appointment (GET /appointments/{id}) ---
    if (method === "GET" && url.pathname.match(/\/appointments\/[^\/]+$/) && !url.pathname.endsWith('/schedule-reminder')) {
        const appointmentId = url.pathname.split("/").pop();
        if (!appointmentId) {
            return new Response(JSON.stringify({ error: "Appointment ID is required" }), {
                status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" }
            });
        }

        const { data: appointment, error } = await supabase
            .from('appointments')
            .select(`
                id, customer_id, service_id, location_id, staff_id_assigned, status_new, 
                scheduled_time, check_in_time, service_start_time, service_end_time, 
                customer_notes, cancellation_reason, reschedule_original_appointment_id, 
                created_at, updated_at,
                service:services(name, description),
                location:locations(name),
                staff:profiles!appointments_staff_id_assigned_fkey(full_name),
                customer:profiles!appointments_customer_id_fkey(full_name, email, phone)
            `)
            .eq('id', appointmentId)
            .single();

        if (error || !appointment) {
            return new Response(JSON.stringify({ error: "Appointment not found", details: error?.message }), {
                status: 404, headers: { ...corsHeaders, "Content-Type": "application/json" }
            });
        }

        // Authorization: Customer can see their own, staff/admin can see based on roles
        const { data: userProfile } = await supabase.from('profiles').select('role, location_id').eq('id', user.id).single();
        const userRole = userProfile?.role || 'customer';

        if (userRole === 'customer' && appointment.customer_id !== user.id) {
             return new Response(JSON.stringify({ error: "Unauthorized to view this appointment" }), {
                status: 403, headers: { ...corsHeaders, "Content-Type": "application/json" }
            });
        }
        // Staff/Admin access can be further refined if needed (e.g. staff only for their location)

        return new Response(JSON.stringify(appointment as AppointmentResponse), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
    }

    // --- Update Appointment (PATCH /appointments/{id}) ---
    if (method === "PATCH" && url.pathname.match(/\/appointments\/[^\/]+$/)) {
      const appointmentId = url.pathname.split("/").pop();
      if (!appointmentId) {
        return new Response(JSON.stringify({ error: "Appointment ID is required" }), {
          status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }

      const body = await req.json();
      const validation = UpdateAppointmentSchema.safeParse(body);
      if (!validation.success) {
        return new Response(JSON.stringify({ error: "Invalid request data for updating appointment", details: validation.error.format() }), {
          status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      const updateData = validation.data;

      // Authorization: Only staff/admin can update (or customer for cancellation if allowed)
      const { data: userProfile } = await supabase.from('profiles').select('role').eq('id', user.id).single();
      if (!userProfile || !['staff', 'admin'].includes(userProfile.role)) {
         // Add logic here if customers are allowed to cancel/reschedule their own appointments
         if (updateData.status_new === 'cancelled' && req.method === 'PATCH') {
            const {data: apptToCancel} = await supabase.from('appointments').select('customer_id').eq('id', appointmentId).single();
            if(apptToCancel?.customer_id !== user.id) {
                 return new Response(JSON.stringify({ error: "Unauthorized to update this appointment" }), {
                    status: 403, headers: { ...corsHeaders, "Content-Type": "application/json" }
                });
            }
         } else {
            return new Response(JSON.stringify({ error: "Unauthorized to update this appointment" }), {
                status: 403, headers: { ...corsHeaders, "Content-Type": "application/json" }
            });
         }
      }

      const updatePayload: any = { ...updateData };
      if (updateData.status_new === 'checked_in' && !updateData.check_in_time) {
        updatePayload.check_in_time = new Date().toISOString();
      }
      if (updateData.status_new === 'servicing' && !updateData.service_start_time) {
        updatePayload.service_start_time = new Date().toISOString();
      }
      if (updateData.status_new === 'completed' && !updateData.service_end_time) {
        updatePayload.service_end_time = new Date().toISOString();
      }

      const { data: updatedAppointment, error } = await supabase
        .from('appointments')
        .update(updatePayload)
        .eq('id', appointmentId)
        .select("*, service:services(name), location:locations(name), customer:profiles(full_name, email, phone)")
        .single();

      if (error) {
        console.error("Error updating appointment:", error);
        return new Response(JSON.stringify({ error: "Failed to update appointment", details: error.message }), {
          status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" }
        });
      }
      return new Response(JSON.stringify(updatedAppointment as AppointmentResponse), { headers: { ...corsHeaders, "Content-Type": "application/json" } });
    }

    return new Response(JSON.stringify({ error: "Method not allowed or endpoint not found" }), {
      status: 405, headers: { ...corsHeaders, "Content-Type": "application/json" }
    });

  } catch (error) {
    console.error("Unexpected error in appointmentHandler:", error);
    return new Response(JSON.stringify({ error: "Internal server error", details: error.message }), {
      status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  }
});

serve(appointmentHandler);

